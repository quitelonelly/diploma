import io
import os

from dotenv import load_dotenv
from passlib.context import CryptContext
from datetime import datetime, timedelta
from jose import JWTError, jwt
from typing import Annotated

from fastapi import Depends, FastAPI, File, HTTPException, UploadFile, status, Security, Body
from fastapi.responses import JSONResponse, StreamingResponse
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
import urllib

from backend.repository import TaskRepository, UserRepository, SubtaskRepository
from backend.shemas import FileAdd, ResponsibleAdd, Task, TaskAdd, User, UserAdd, Subtask, SubtaskAdd, UserUpdate
from backend.utils import hash_password, verify_password


app = FastAPI(
    title="Pulse"
)

load_dotenv()

SECRET_KEY = os.getenv("SECRET_KEY")
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Ö–µ—à–∏—Ä–æ–≤–∞–Ω–∏—è –ø–∞—Ä–æ–ª–µ–π
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è OAuth2
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

# –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è —Ç–æ–∫–µ–Ω–∞
def create_access_token(data: dict, expires_delta: timedelta = None) -> str:
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=15)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)

    return encoded_jwt

# –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Ç–µ–∫—É—â–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
async def get_current_user(token: str = Security(oauth2_scheme)):
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        user_id: str = payload.get("sub")
        if user_id is None:
            raise credentials_exception
        return user_id  # –í–æ–∑–≤—Ä–∞—â–∞–µ–º ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    except JWTError:
        raise credentials_exception
    
@app.post("/token", tags=["–ê—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è"], summary="–ü–æ–ª—É—á–∏—Ç—å —Ç–æ–∫–µ–Ω –¥–æ—Å—Ç—É–ø–∞")
async def login(form_data: OAuth2PasswordRequestForm = Depends()) -> dict:
    user = await UserRepository.get_user_by_username(form_data.username)  # –°–æ–∑–¥–∞–π—Ç–µ —ç—Ç–æ—Ç –º–µ—Ç–æ–¥ –≤ UserRepository
    if not user or not verify_password(form_data.password, user.userpass):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="–ù–µ–≤–µ—Ä–Ω—ã–µ —É—á–µ—Ç–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ",
            headers={"WWW-Authenticate": "Bearer"},
        )
    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(data={"sub": user.id}, expires_delta=access_token_expires)
    return {"access_token": access_token, "token_type": "bearer"}

# –ó–∞–ø–∏—Å—å –Ω–æ–≤–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
@app.post("/users", tags=["–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ üë§"], summary="–î–æ–±–∞–≤–∏—Ç—å –Ω–æ–≤–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è")
async def add_user(user: Annotated[UserAdd, Depends()]) -> JSONResponse:
    user_id = await UserRepository.add_user(user)

    # –°–æ–∑–¥–∞–µ–º —Ç–æ–∫–µ–Ω –¥–ª—è –Ω–æ–≤–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(data={"sub": user_id}, expires_delta=access_token_expires)

    return {"User  added": True, "user_id": user_id, "access_token": access_token, "token_type": "bearer"}

# –ü–æ–ª—É—á–µ–Ω–∏–µ –≤—Å–µ—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è
@app.get("/users", tags=["–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ üë§"], summary="–ü–æ–ª—É—á–∏—Ç—å –≤—Å–µ—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π")
async def get_users() -> list[User]:
    users = await UserRepository.get_users()
    return users

# –ü–æ–ª—É—á–µ–Ω–∏–µ —Ä–æ–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
@app.get("/users/role", tags=["–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ üë§"], summary="–ü–æ–ª—É—á–∏—Ç—å —Ä–æ–ª—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è")
async def get_user_role_by_username(username: str) -> str:
    role = await UserRepository.get_user_role_by_username(username)
    return role

# –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
@app.put("/users", tags=["–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ üë§"], summary="–û–±–Ω–æ–≤–∏—Ç—å –¥–∞–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è")
async def update_user(user: Annotated[UserUpdate, Depends()]) -> JSONResponse:
    updated = await UserRepository.update_user(user)
    if updated:
        return {"User updated": True}
    return JSONResponse(status_code=404, content={"message": "User not found"})


# –ó–∞–ø–∏—Å—å –Ω–æ–≤–æ–π –∑–∞–¥–∞—á–∏
@app.post("/tasks", tags=["–ó–∞–¥–∞—á–∏ üìù"], summary="–î–æ–±–∞–≤–∏—Ç—å –Ω–æ–≤—É—é –∑–∞–¥–∞—á—É")
async def add_task(task: Annotated[TaskAdd, Depends()]) -> JSONResponse:
    task_id = await TaskRepository.add_task(task)
    return {"Task added": True, "task_id": task_id}

# –ü–æ–ª—É—á–µ–Ω–∏–µ –≤—Å–µ—Ö –∑–∞–¥–∞—á
@app.get("/tasks", tags=["–ó–∞–¥–∞—á–∏ üìù"], summary="–ü–æ–ª—É—á–∏—Ç—å –≤—Å–µ –∑–∞–¥–∞—á–∏")
async def get_tasks() -> list[Task]:
    tasks = await TaskRepository.get_tasks()
    return tasks

@app.delete("/tasks/{task_id}", tags=["–ó–∞–¥–∞—á–∏ üìù"], summary="–£–¥–∞–ª–∏—Ç—å –∑–∞–¥–∞—á—É")
async def delete_task(task_id: int) -> JSONResponse:
    deleted = await TaskRepository.delete_task(task_id)
    if deleted:
        return {"message": "Task deleted successfully"}
    return JSONResponse(status_code=404, content={"message": "Task not found"})
    
# –ü–æ–ª—É—á–µ–Ω–∏–µ –∑–∞–¥–∞—á –ø–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
@app.get("/tasks/{user_id}", tags=["–ó–∞–¥–∞—á–∏ üìù"], summary="–ü–æ–ª—É—á–∏—Ç—å –∑–∞–¥–∞—á–∏ –ø–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é")
async def get_tasks_by_user_id(user_id: int) -> list[Task]:
    tasks = await TaskRepository.get_tasks_by_user_id(user_id)
    return tasks

@app.get("/tasks/{task_id}/responsibles", tags=["–ó–∞–¥–∞—á–∏ üìù"], summary="–ü–æ–ª—É—á–∏—Ç—å –∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª–µ–π –ø–æ ID –∑–∞–¥–∞—á–∏")
async def get_responsibles_by_task_id(task_id: int) -> JSONResponse:
    responsibles = await TaskRepository.get_responsibles_by_task_id(task_id)
    if responsibles:
        return JSONResponse(content={"responsibles": responsibles})
    return JSONResponse(status_code=404, content={"message": "No responsibles found for this task"})

# –ó–∞–ø–∏—Å—å –æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ–≥–æ –∑–∞ –∑–∞–¥–∞—á—É
@app.post("/tasks/responsibles", tags=["–ó–∞–¥–∞—á–∏ üìù"], summary="–î–æ–±–∞–≤–∏—Ç—å –æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ–≥–æ –∑–∞ –∑–∞–¥–∞—á—É")
async def assign_responsible(responsible: Annotated[ResponsibleAdd, Depends()]) -> JSONResponse:
    try:
        success = await TaskRepository.add_responsible(responsible)
        if success:
            return {"message": "Responsible assigned successfully"}
        return JSONResponse(status_code=400, content={"message": "Failed to assign responsible"})
    except Exception as e:
        print(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ –∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—è: {e}")  # –õ–æ–≥–∏—Ä—É–µ–º –æ—à–∏–±–∫—É
        return JSONResponse(status_code=500, content={"message": "Internal Server Error"})
    
# –£–¥–∞–ª–µ–Ω–∏–µ –æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ–≥–æ –∑–∞ –∑–∞–¥–∞—á—É
@app.delete("/tasks/responsibles/{task_id}/{user_id}", tags=["–ó–∞–¥–∞—á–∏ üìù"], summary="–£–¥–∞–ª–∏—Ç—å –æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ–≥–æ –∑–∞ –∑–∞–¥–∞—á—É")
async def remove_responsible(task_id: int, user_id: int) -> JSONResponse:
    print(f"–£–¥–∞–ª–µ–Ω–∏–µ –∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—è: task_id={task_id}, user_id={user_id}")
    try:
        success = await TaskRepository.delete_responsible(task_id, user_id)
        if success:
            return {"message": "Responsible removed successfully"}
        return JSONResponse(status_code=404, content={"message": "Failed to remove responsible"})
    except Exception as e:
        print(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ –∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—è: {e}")  # –õ–æ–≥–∏—Ä—É–µ–º –æ—à–∏–±–∫—É
        return JSONResponse(status_code=500, content={"message": "Internal Server Error"})

# –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –Ω–∞–∑–≤–∞–Ω–∏—è –∑–∞–¥–∞—á–∏
@app.put("/tasks/{task_id}/name", tags=["–ó–∞–¥–∞—á–∏ üìù"], summary="–û–±–Ω–æ–≤–∏—Ç—å –Ω–∞–∑–≤–∞–Ω–∏–µ –∑–∞–¥–∞—á–∏")
async def update_task_name(task_id: int, new_name: str) -> JSONResponse:
    updated = await TaskRepository.update_task_name(task_id, new_name)
    if updated:
        return {"message": "Task name updated successfully"}
    return JSONResponse(status_code=404, content={"message": "Task not found"})

# –ó–∞–ø–∏—Å—å –Ω–æ–≤–æ–π –ø–æ–¥–∑–∞–¥–∞—á–∏
@app.post("/subtasks/{task_id}", tags=["–ó–∞–¥–∞—á–∏ üìù"], summary="–î–æ–±–∞–≤–∏—Ç—å –Ω–æ–≤—É—é –ø–æ–¥–∑–∞–¥–∞—á—É")
async def add_subtask(task_id: int, subtask: Annotated[SubtaskAdd, Depends()]) -> JSONResponse:
    subtask_id = await SubtaskRepository.add_subtask(task_id, subtask)
    return {"Subtask added": True, "subtask_id": subtask_id}

# –ü–æ–ª—É—á–µ–Ω–∏–µ –ø–æ–¥–∑–∞–¥–∞—á –ø–æ –∑–∞–¥–∞—á–µ
@app.get("/subtasks/{task_id}", tags=["–ó–∞–¥–∞—á–∏ üìù"], summary="–ü–æ–ª—É—á–∏—Ç—å –ø–æ–¥–∑–∞–¥–∞—á–∏ –ø–æ –∑–∞–¥–∞—á–µ")
async def get_subtasks_by_task_id(task_id: int) -> list[Subtask]:
    subtasks = await SubtaskRepository.get_subtasks(task_id)
    return subtasks

# –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞ –ø–æ–¥–∑–∞–¥–∞—á–∏
@app.put("/subtasks/{subtask_id}/status", tags=["–ó–∞–¥–∞—á–∏ üìù"], summary="–û–±–Ω–æ–≤–∏—Ç—å —Å—Ç–∞—Ç—É—Å –ø–æ–¥–∑–∞–¥–∞—á–∏")
async def update_subtask_status(subtask_id: int, new_status: str) -> JSONResponse:
    updated = await SubtaskRepository.update_subtask_status(subtask_id, new_status)
    if updated:
        return {"message": "Subtask status updated successfully"}
    return JSONResponse(status_code=404, content={"message": "Subtask not found"})

# –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –Ω–æ–≤–æ–≥–æ —Ñ–∞–π–ª–∞
@app.post("/files", tags=["–§–∞–π–ª—ã üìÅ"], summary="–ó–∞–≥—Ä—É–∑–∏—Ç—å —Ñ–∞–π–ª")
async def upload_file(file: UploadFile = File(...), task_id: int = Body(...)) -> JSONResponse:
    try:
        file_data = await file.read()  # –ß–∏—Ç–∞–µ–º —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ —Ñ–∞–π–ª–∞
        file_upload = FileAdd(task_id=task_id, file_name=file.filename, file_data=file_data)
        
        # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ñ–∞–π–ª –≤ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–∏
        await TaskRepository.add_file(file_upload)
        
        return JSONResponse(status_code=201, content={"message": "File uploaded successfully"})
    except Exception as e:
        print(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Ñ–∞–π–ª–∞: {e}")  # –õ–æ–≥–∏—Ä—É–µ–º –æ—à–∏–±–∫—É
        return JSONResponse(status_code=500, content={"message": "Internal Server Error"})
    
# –ü–æ–ª—É—á–µ–Ω–∏–µ –≤—Å–µ—Ö —Ñ–∞–π–ª–æ–≤ –ø–æ ID –∑–∞–¥–∞—á–∏
@app.get("/tasks/{task_id}/files", tags=["–§–∞–π–ª—ã üìÅ"], summary="–ü–æ–ª—É—á–∏—Ç—å –≤—Å–µ —Ñ–∞–π–ª—ã –ø–æ ID –∑–∞–¥–∞—á–∏")
async def get_files_by_task_id(task_id: int) -> JSONResponse:
    files = await TaskRepository.get_files_by_task_id(task_id)
    if files:
        return JSONResponse(content=[{
            "id": file.id,
            "file_name": file.file_name,
        } for file in files])
    
    return JSONResponse(status_code=404, content={"message": "No files found for this task"})

# –ü–æ–ª—É—á–µ–Ω–∏–µ —Ñ–∞–π–ª–∞ –ø–æ ID
@app.get("/files/{file_id}", tags=["–§–∞–π–ª—ã üìÅ"], summary="–°–∫–∞—á–∞—Ç—å —Ñ–∞–π–ª –ø–æ ID")
async def download_file(file_id: int) -> StreamingResponse:
    file_data = await TaskRepository.get_file_by_id(file_id)
    if file_data:
        # –ö–æ–¥–∏—Ä—É–µ–º –∏–º—è —Ñ–∞–π–ª–∞ –¥–ª—è –∑–∞–≥–æ–ª–æ–≤–∫–∞
        encoded_file_name = urllib.parse.quote(file_data.file_name)

        return StreamingResponse(
            io.BytesIO(file_data.file_data),
            media_type="application/octet-stream",
            headers={"Content-Disposition": f"attachment; filename*=UTF-8''{encoded_file_name}"}
        )

    raise HTTPException(status_code=404, detail="File not found")

# –£–¥–∞–ª–µ–Ω–∏–µ —Ñ–∞–π–ª–∞ –ø–æ ID
@app.delete("/files/{file_id}", tags=["–§–∞–π–ª—ã üìÅ"], summary="–£–¥–∞–ª–∏—Ç—å —Ñ–∞–π–ª –ø–æ ID")
async def delete_file(file_id: int) -> JSONResponse:
    success = await TaskRepository.delete_file(file_id)
    if success:
        return {"message": "File deleted successfully"}
    return JSONResponse(status_code=404, content={"message": "File not found"})


